- Add more error / corner case handling logic. Improve/enhance/increase robustness.
- Use optimization mode when packaging to executable file.
- Use executable compression utility to reduce executable size.
- Implement a non-tech-savvy-user-friendly GUI. Try the goose library.
- Add docstring to functions, for better maintenance
- requests library's response type's default encoding ? Is it UTF-8?
- Investigate whether click library is lightweight. Whether it contains C extension module. Whether it's more lightweight to use builtin argparse library.
- Use Rust to rewrite.
- Use color output in console. Use library like colorama, colored.
- Add README
- Add LICENSE
- Leverage concurrent programming to accelerate network IO. Take inspiration from black and autopep8's code about concurrently formatting multiple files. Use asyncio, multiprocessing, concurrent.futures, threading library.
- Read the book "High Performance Python" and deploy some tricks fromt there. Especially the part about mitigating expensive network IO>
- Reduce overhead of network IO, which is expensive.
- Use line profiler to find performance hotspots.
- Inspect the dependency graph generated from PyInstaller and figure out which third-party library is the the heavy one that takes up most of the size of the generated executable file.
  - Experiment shows that applying `pyinstaller --onefile` on an empty Python file yields a 9.7MB executable. Probably this is the minimal executable size generated by PyInstaller.
  - Read PyInstaller document's section about Advanced Usage.
- Use timeit to profile which is more performant: re.fullmatch(r"\d{6}", s) or test numberness of all chars.
- Figure out why using pyinstaller with upx will lead to erroneous executable.
- Try some other freeze tools other than pyinstaller. See if they can lead to smaller executable size and smaller executable startup time.
- Don't close immediately after success or failure.
- When fail, print clean succint intuitive user-friendly stack trace. Consider use logging, warning modules.
- Implement auto update detector
- Setup autonomous workflow to auto build executable and publish to GitHub release page. Perhaps use CI pipeline setup or GitHub Actions.
- Push archived executable to GitHub. Since GitHub release page doesn't permit Chinese character name asserts.
- Try some other executable compression utility tools. Turn out that UPX doesn't give us meaningful compression ratio.
- Any compression algorithm targeted at binary file instead of text? Try to do some literature review on this research topic.
- Recompile and archive and publish to old release page.
- Open a feature branch to try on Gooey.
- Use lightweight utlity tool to preview content Excel document. So that we don't have to wait for the heavyweight Excel program to startup everytime we want to test on our program.
- Read semver.org. Understand deeply how to choose proper version number.
- Instead of using raw print and raise exception, use logging and warning module to print out more user-friendly messages.
- Add auto workflow to bump version.
- Try Git workflow model like trunk-based, GitFlow.
- Add executable hash signature in GitHub release page, for security verification.
- Use advanced feature from click. Take inspiration from black library.
  - click.Path
  - click.version_option()
  - click.context
- Arrange TODO entries into groups with respectively different priority. Streamline workflow.
- Vim movement, jumping, jump back, mark.
- Try to use more modernized python project dependency management tools, like poetry, pyproject. Instead of using the naive requirements.txt method.
- Use requests' response.json() sugar shortcut.
- exit() vs sys.exit() vs quit(). What's the difference? Which should we use?
  - atexit module
- standard library's `atexit` module.
- rg TODO
- Specify minimal supported Python version.
- On failure or exception, log message to file instead of printing to bother non-tech-savvy user.
- Add unit test suite/framework. Tox, pytest, nose.
- Add pre-commit hook script. Lint, reformat, bump version.
- Play with atext hook to reason about its behaviour.
  - When program successfully finishes.
  - When program terminates due to uncaught exception.
  - When program terminates due to call to exit()/sys.exit()/quit().
- Use setup.py to install console script.
- Adopt `conventional commit` conventions.
- Auto workflow to calculate SHA256 hash signature of the released zip file and the released executable file.
- Polish the `--help` generated message.
- Search on the internet about existing project that make async possible with requests library.


## Archive

- 考虑在输出文件名中添加时间戳后缀
