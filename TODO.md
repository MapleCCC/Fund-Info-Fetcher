- Add more error / corner case handling logic. Improve/enhance/increase robustness.
- Use optimization mode when packaging to executable file.
- Use executable compression utility to reduce executable size.
- Implement a non-tech-savvy-user-friendly GUI. Try the goose library.
- Add docstring to functions, for better maintenance
- Investigate whether click library is lightweight. Whether it contains C extension module. Whether it's more lightweight to use builtin argparse library.
- Use Rust to rewrite.
- Use color output in console. Use library like colorama, colored.
- Add README
- Leverage concurrent programming to accelerate network IO. Take inspiration from black and autopep8's code about concurrently formatting multiple files. Use asyncio, multiprocessing, concurrent.futures, threading library.
- Read the book "High Performance Python" and deploy some tricks from there. Especially the part about mitigating expensive network IO.
- Reduce overhead of network IO, which is expensive.
- Use line profiler to find performance hotspots.
- Inspect the dependency graph generated from PyInstaller and figure out which third-party library is the the heavy one that takes up most of the size of the generated executable file.
  - Experiment shows that applying `pyinstaller --onefile` on an empty Python file yields a 9.7MB executable. Probably this is the minimal executable size generated by PyInstaller.
  - Read PyInstaller document's section about Advanced Usage.
- Use timeit to profile which is more performant: re.fullmatch(r"\d{6}", s) or test numberness of all chars.
- Figure out why using pyinstaller with upx will lead to erroneous executable.
- Try some other freeze tools other than pyinstaller. See if they can lead to smaller executable size and smaller executable startup time.
- Don't close immediately after success or failure.
- When fail, print clean succint intuitive user-friendly stack trace. Consider use logging, warning modules.
- Implement auto update detector
- Setup autonomous workflow to auto build executable and publish to GitHub release page. Perhaps use CI pipeline setup or GitHub Actions.
- Push archived executable to GitHub. Since GitHub release page doesn't permit Chinese character name asserts.
- Try some other executable compression utility tools. Turn out that UPX doesn't give us meaningful compression ratio.
- Any compression algorithm targeted at binary file instead of text? Try to do some literature review on this research topic.
- Recompile and archive and publish to old release page.
- Open a feature branch to try on Gooey.
- Use lightweight utlity tool to preview content Excel document. So that we don't have to wait for the heavyweight Excel program to startup everytime we want to test on our program.
- Read semver.org. Understand thoroughly how to choose proper version number.
- Instead of using raw print and raise exception, use logging and warning module to print out more user-friendly messages.
- Add auto workflow to bump version.
- Try Git workflow model like trunk-based, GitFlow.
- Add executable hash signature in GitHub release page, for security verification.
- Use advanced feature from click. Take inspiration from black library.
  - click.Path
  - click.version_option()
  - click.context
- Arrange TODO entries into groups with respectively different priority. Streamline workflow.
- Vim movement, jumping, jump back, mark.
- Try to use more modernized python project dependency management tools, like poetry, pyproject. Instead of using the naive requirements.txt method.
- Use requests' response.json() sugar shortcut.
- exit() vs sys.exit() vs quit(). What's the difference? Which should we use?
  - atexit module
- standard library's `atexit` module.
- See content of `rg TODO`
- Specify minimal supported Python version.
- On failure or exception, log message to file instead of printing to bother non-tech-savvy user.
- Add unit test suite/framework. Tox, pytest, nose.
- Add pre-commit hook script. Lint, reformat, bump version.
- Play with atexit hook to reason about its behaviour.
  - When program successfully finishes.
  - When program terminates due to uncaught exception.
  - When program terminates due to call to exit()/sys.exit()/quit().
- Use setup.py to install console script.
- Adopt `conventional commit` conventions.
- Auto workflow to calculate SHA256 hash signature of the released zip file and the released executable file.
- Polish the `--help` generated message.
- Search on the internet about existing project that make async possible with requests library.
- Script to auto check update daily.
- User experience design: when doing long time processing, create some animated UI to let user understand that something is going on and the process is not dead.
- Find way to quick unit test, integrate test, regression test. No need to stand up with the startup time overhead of the super heavyweight Excel program anymore.
- Use requests session to leverage connection pool.
- Use requests body content flow stream. So we can display progress bar when downloading or uploading large files.
- Install to context menu, so that the user only needs to open the context menu of a file and then click our program. The UX is more intuitive and straightforward.
- Try to search on the internet and find some other fund APIs.
- Careful about the web request cache. This could lead to outdated information. How to disable web request cache?
- We really need to handle the lengthy startup time of the executable generated by PyInstaller. This is unbearable and detrimental to the user experience.
- One way to overcome the difficulty of distribution and lengthy executable startup time, is to use client/server model. By client/server model, user doesn't need to know anything about the change of the underlying implmentation. The burden of updating to latest version is now off the shoulder of user.
- Deploy pre-commit hook using the famous "pre-commit" repository.
  - Reformat staged Python code with `isort` and `black`
  - Linting
- Open a feature branch to work on client/server architecture.
- Too many issues and feature requests. Consider using GitHub's issue system.
- Try PyPy to accelerate the script.
- After switching to client/server architecture, we don't need to embed the auto update detection logic any more. Remove the additional network IO overhead.
- See content of snippets.py
- Issue: tqdm progress bar is not displayed correctly in some console environment.
- Issue: color code output is not displayed correctly in some console environment.
- Try to use Nuikta to compile into performant standalone executable.
- Fill more details and instructions to README.
- Try some easy-to-use GUI library.
- Try to use Django to build a server backend.
- Append content of TODO.md and CHANGELOG.md to README.md
- Compare namedtuple, user-defined class, dict, Enum, dataclass, and attrs library.
- Pin the dependencies' versions. Use exact version for max robustness and compatibility.
  - Use some utility tool to help automatically find all third-party library used in the repository.
  - Inspect pipreq library's source code. Figure out how it identifies an import as third-party import.
- Consider use "WARN:" to replace "WARNING:" in comments.
- Open issue: Pylance doesn't signal error when a non-existent method is called from a dataclass instance.
- When getting fund info of fund code 519674, a error is raised saying that NoneType has no member 'group'.
- Maybe it's okay to let autopep8 check all, instead of just check E501. Some other problems are worth addressed. Like changing "x == None" to "x is None", and changing "except:" to "except BaseException:".
- Make it a good habit to add elaborte comments and docstring and docs. This is important and has long-lasting benefits for other people to read my code, including the the guy called "future me".
- Turn out that Pylance static type checker doesn't do a good job in checking about dataclass. It doesn't signal error when a field is assigned a value of type not the same with the type annotation in dataclass definition. It doesn't signal error when dataclass instance is assigned new property dynamically. It doesn't signal error when a non-existent method is called from a datalcass instance.


## Archive

- 考虑在输出文件名中添加时间戳后缀
- requests library's response type's default encoding ? Is it UTF-8?
  - From requests document, it try to make smart guess of the response's text encoding.
